;;; 2048.lisp - 2048 Game (Auto)
;;; 2019/03/10 go版からSBCL版に移植開始
;;; 2019/03/27 バグありだが落ちずに動く (バグ：whenを使うべき箇所でifを使っていた）
;;; 2019/03/30 直訳版完成（その他Averageなど細かなバグ修正）
;;; 2019/03/30 マクロ化
"
Game Over! (level=3 seed=1) 2019/03/30 22:49:18 #1 Ave.=36616.0 Max=36616(seed=1) Min=36616(seed=1)
getGap=2889850 calcGap=58753086 10.0,0.0 55%,1 20000,1 10%,1 200000,1 1 *calc_gap_mode*=0
Total time = 210.6 (sec)
Evaluation took:
  210.597 seconds of real time
    210.437692 seconds of total run time (210.187387 user, 0.250305 system)
      [ Run times consist of 0.740 seconds GC time, and 209.698 seconds non-GC time. ]
        99.92% CPU
          5 forms interpreted
            2,246,930,824 bytes consed
"

(defconstant true t)
(defconstant false nil)

(defconstant D_BONUS 10)
(defconstant D_BONUS_USE_MAX true) ; 10固定ではなく最大値とする
(defconstant AUTO_MODE 4) ; >=0 depth
(defconstant CALC_GAP_MODE 0) ; gap計算モード(0:normal 1:端の方が小さければ+1 2:*2 3:+大きい方の値 4:+大きい方の値/10 5:+両方の値)
(defconstant GAP_EQUAL 0)
(defconstant PRINT_MODE 100)
(defconstant PRINT_MODE_TURBO 1)
(defconstant PAUSE_MODE 0)
(defconstant TURBO_MINUS_PERCENT 55)
(defconstant TURBO_MINUS_PERCENT_LEVEL 1)
(defconstant TURBO_MINUS_SCORE 20000)
(defconstant TURBO_MINUS_SCORE_LEVEL 1)
(defconstant TURBO_PLUS_PERCENT 10)
(defconstant TURBO_PLUS_PERCENT_LEVEL 1)
(defconstant TURBO_PLUS_SCORE 200000)
(defconstant TURBO_PLUS_SCORE_LEVEL 1)

(defconstant INIT2 1)
(defconstant INIT4 2)
(defconstant RNDMAX 4)
(defconstant GAP_MAX 100000000.0)
(defconstant XMAX 4)
(defconstant YMAX 4)
(defconstant MICRO_SECOND 1000000)

(defvar *board* (make-array (list XMAX YMAX) :element-type 'fixnum))
(defvar *seed* 1)
(defvar *sp* 0)

(defvar *pos_x* (make-array (* XMAX YMAX) :element-type 'fixnum))
(defvar *pos_y* (make-array (* XMAX YMAX) :element-type 'fixnum))
(defvar *pos_val* (make-array (* XMAX YMAX) :element-type 'fixnum))
(defvar *score* 0)
(defvar *gen* 0)
(defvar *count_2* 0)
(defvar *count_4* 0)
(defvar *count_calcGap* 0)
(defvar *count_getGap* 0)
(defvar *auto_mode* AUTO_MODE)
(defvar *calc_gap_mode* CALC_GAP_MODE)
(defvar *print_mode* PRINT_MODE)
(defvar *print_mode_turbo* PRINT_MODE_TURBO)
(defvar *pause_mode* PAUSE_MODE)
(defvar *turbo_minus_percent* TURBO_MINUS_PERCENT)
(defvar *turbo_minus_percent_level* TURBO_MINUS_PERCENT_LEVEL)
(defvar *turbo_minus_score* TURBO_MINUS_SCORE)
(defvar *turbo_minus_score_level* TURBO_MINUS_SCORE_LEVEL)
(defvar *turbo_plus_percent* TURBO_PLUS_PERCENT)
(defvar *turbo_plus_percent_level* TURBO_PLUS_PERCENT_LEVEL)
(defvar *turbo_plus_score* TURBO_PLUS_SCORE)
(defvar *turbo_plus_score_level* TURBO_PLUS_SCORE_LEVEL)
(defvar *start_time* 0)
(defvar *last_time* 0)
(defvar *total_start_time* 0)
(defvar *total_last_time* 0)
(defvar *one_time* 0)
(defvar *count* 0)
(defvar *sum_score* 0)
(defvar *max_score* 0)
(defvar *max_seed* 0)
(defvar *min_score* most-positive-fixnum)
(defvar *min_seed* 0)
(defvar *random-state-org* (make-random-state))
(defvar *random-state-use* (make-random-state *random-state-org*))

(defmacro while (test &rest body)
    `(do ()
        ((not ,test))
      ,@body))

(defmacro now()
    ;;(get-time-of-day)
    ;;(get-internal-real-time)
    ;;(get-universal-time)
    `(multiple-value-bind (sec microsec) (get-time-of-day) (+ (* sec MICRO_SECOND) microsec))
)

(defmacro rand(n)
  `(random ,n *random-state-use*)
)

(defun seed(seed)
    (cond ((zerop seed)
        (setq *random-state-use* (make-random-state t)))
        (t
            (setq *random-state-use* (make-random-state *random-state-org*))
            (dotimes (i seed)
                (rand 65536)
            )
        )
    )
)

(defmacro getCell (x y)
	`(aref *board* ,x ,y)
)

(defmacro setCell(x y n)
	`(setf (aref *board* ,x ,y) ,n)
)

(defmacro clearCell(x y)
	`(setCell ,x ,y 0)
)

(defmacro copyCell(x1 y1 x2 y2)
	`(setCell ,x2 ,y2 (getCell ,x1 ,y1))
)

(defmacro moveCell(x1 y1 x2 y2)
    `(progn
        (copyCell ,x1 ,y1 ,x2 ,y2)
        (clearCell ,x1 ,y1)
    )
)

(defmacro addScore(sc)
	`(incf *score* ,sc)
)

(defmacro addCell(x1 y1 x2 y2)
    `(progn
        (incf (aref *board* ,x2 ,y2))
        (clearCell ,x1 ,y1)
        (if (< *sp* 1)
            (addScore (expt 2 (getCell ,x2 ,y2)))
        )
    )
)

(defmacro isEmpty(x y)
	`(zerop (getCell ,x ,y))
)

(defmacro isNotEmpty(x y)
	`(not (isEmpty ,x ,y))
)

(defmacro getScore()
	`*score*
)

(defmacro setScore(sc)
	`(setq *score* ,sc)
)

(defmacro clear()
    `(dotimes (y YMAX)
        (dotimes (x XMAX)
			(clearCell x y)
		)
	)
)

(defmacro countEmpty()
  `(let
    ((ret 0))
	(dotimes (y YMAX)
		(dotimes (x XMAX)
			(if (isEmpty x y)
				(incf ret)
			)
		)
	)
	ret
  )
)

(defun getTime() (prog () ;string
    (multiple-value-bind
        (second minute hour date month year week daylight-savings-time timezone)
        (get-decoded-time) ;= (decode-universal-time (get-universal-time))
        (declare (ignore week daylight-savings-time timezone))
        (return (format nil "~4,'0D/~2,'0D/~2,'0D ~2,'0D:~2,'0D:~2,'0D" year month date hour minute second))
    )
))

(defun appear() (prog ;bool
    ((n 0))
	(dotimes (y YMAX)
        (dotimes (x XMAX)
			(when (isEmpty x y)
                (setf (aref *pos_x* n) x)
                (setf (aref *pos_y* n) y)
                (incf n)
			)
		)
	)
	(if (> n 0)
		(let ((v) (i (mod (rand 65535) n)))
            (if (>= (mod (rand 65535) RNDMAX) 1)
                (progn
                    (setq v INIT2)
                    (incf *count_2*)
                )
                (progn
                    (setq v INIT4)
                    (incf *count_4*)
                )
            )
            (let ((x (aref *pos_x* i)) (y (aref *pos_y* i)))
                (setCell x y v)
            )
            (return true)
        )
	)
	(return false)
))

(defun disp(gap debug) (prog
    ((now (now)))
	(if (zerop *count*)
        (format t "[~S:~S] ~S (~,2F/~,1F sec) ~,6F ~A seed=~S 2=~,2F~A" *count* *gen* (getScore) (/ (- now *last_time*) MICRO_SECOND) (/ (- now *start_time*) MICRO_SECOND) gap (getTime) *seed* (float (/ *count_2* (+ *count_2* *count_4*) 1/100)) (code-char 13))
		(format t "[~S:~S] ~S (~,2F/~,1F sec) ~,6F ~A seed=~S 2=~,2F Ave.=~S~A" *count* *gen* (getScore) (/ (- now *last_time*) MICRO_SECOND) (/ (- now *start_time*) MICRO_SECOND) gap (getTime) *seed* (float (/ *count_2* (+ *count_2* *count_4*) 1/100)) (float (/ (+ *sum_score* (getScore)) *count*)) (code-char 13))
	)
    (finish-output)
	(setq *last_time* now)
	(when debug
		(format t "~%")
		(dotimes (x XMAX)
			(dotimes (y YMAX)
				(let ((v (getCell x y)))
                    (if (> v 0)
                        (format t "~5D " (expt 2 v))
                        (format t "~5@A " ".")
                    )
                )
			)
			(format t "~%")
		)
	)
))

(defun init_game()
	(setq *count_calcGap* 0)
	(setq *count_getGap* 0)
	(setq *sp* 0)
	(setq *gen* 1)
	(setq *count_2* 0)
	(setq *count_4* 0)
	(setScore 0)
	(setq *start_time* (now))
	(setq *last_time* *start_time*)
	(clear)
	(appear)
	(appear)
	(disp 0.0 (eql *print_mode* 1))
)

(defun move_up() (prog
    ((move 0)
     yLimit
     yNext)
	(dotimes (x XMAX)
		(setq yLimit 0)
		(do ((y 1 (1+ y))) ((>= y YMAX))
			(when (isNotEmpty x y)
				(setq yNext (1- y))
				(while (>= yNext yLimit)
					(if (isNotEmpty x yNext)
						(return)
					)
					(if (zerop yNext)
						(return)
					)
					(decf yNext)
				)
				(if (< yNext yLimit)
					(setq yNext yLimit)
				)
				(cond ((isEmpty x yNext)
					(moveCell x y x yNext)
					(incf move))
                  (t
					(cond ((eql (getCell x yNext) (getCell x y))
						(addCell x y x yNext)
						(incf move)
						(setq yLimit (1+ yNext)))
                      (t
						(when (not (eql (1+ yNext) y))
							(moveCell x y x (1+ yNext))
							(incf move)
							(setq yLimit (1+ yNext))
						))
					))
				)
			)
		)
	)
	(return move)
))

(defun move_left() (prog
	((move 0)
	 xLimit
	 xNext)
	(dotimes (y YMAX)
		(setq xLimit 0)
        (do ((x 1 (1+ x))) ((>= x XMAX))
			(when (isNotEmpty x y)
				(setq xNext (1- x))
				(while (>= xNext xLimit)
					(if (isNotEmpty xNext y)
						(return)
					)
					(if (zerop xNext)
						(return)
					)
					(decf xNext)
				)
				(if (< xNext xLimit)
					(setq xNext xLimit)
				)
				(cond ((isEmpty xNext y)
					(moveCell x y xNext y)
					(incf move))
                  (t
					(cond ((eql (getCell xNext y) (getCell x y))
						(addCell x y xNext y)
						(incf move)
						(setq xLimit (1+ xNext)))
					 (t
						(when (not (eql (1+ xNext) x))
							(moveCell x y (1+ xNext) y)
							(incf move)
							(setq xLimit (1+ xNext))
						))
					))
				)
			)
		)
	)
	(return move)
))

(defun move_down() (prog
	((move 0)
	 yLimit
	 yNext)
	(dotimes (x XMAX)
		(setq yLimit (1- YMAX))
        (do ((y (- YMAX 2) (1- y))) ((< y 0))
			(when (isNotEmpty x y)
				(setq yNext (1+ y))
				(while (<= yNext yLimit)
					(if (isNotEmpty x yNext)
						(return)
					)
					(if (eql yNext (1- YMAX))
						(return)
					)
					(incf yNext)
				)
				(if (> yNext yLimit)
					(setq yNext yLimit)
				)
				(cond ((isEmpty x yNext)
					(moveCell x y x yNext)
					(incf move))
                  (t
					(cond ((eql (getCell x yNext) (getCell x y))
						(addCell x y x yNext)
						(incf move)
						(setq yLimit (1- yNext)))
                      (t
						(when (not (eql (1- yNext) y))
							(moveCell x y x (1- yNext))
							(incf move)
							(setq yLimit (1- yNext))
						))
					))
				)
			)
		)
	)
	(return move)
))

(defun move_right() (prog
	((move 0)
	 xLimit
	 xNext)
    (dotimes (y YMAX)
		(setq xLimit (1- XMAX))
        (do ((x (- XMAX 2) (1- x))) ((< x 0))
			(when (isNotEmpty x y)
				(setq xNext (1+ x))
				(while (<= xNext xLimit)
					(if (isNotEmpty xNext y)
						(return)
					)
					(if (eql xNext (1- XMAX))
						(return)
					)
					(incf xNext)
				)
				(if (> xNext xLimit)
					(setq xNext xLimit)
				)
				(cond ((isEmpty xNext y)
					(moveCell x y xNext y)
					(incf move))
                  (t
					(cond ((eql (getCell xNext y) (getCell x y))
						(addCell x y xNext y)
						(incf move)
						(setq xLimit (1- xNext)))
                      (t
						(when (not (eql (1- xNext) x))
							(moveCell x y (1- xNext) y)
							(incf move)
							(setq xLimit (1- xNext))
						))
					))
				)
			)
		)
	)
	(return move)
))

(defun copy-board (board-from board-to)
  (dotimes (x XMAX)
    (dotimes (y YMAX)
        (setf (aref board-to x y) (aref board-from x y))))
  board-to)

(defun isMovable() (prog ;(bool float64)
	((ret false) ;動けるか？
	 (nEmpty 0) ;空きの数
	 (nBonus 1.0) ;ボーナス（隅が最大値ならD_BONUS）
	 max_x max_y
	 (max 0))
	(dotimes (y YMAX)
		(dotimes (x XMAX)
          (let ((val (getCell x y)))
			(cond ((zerop val)
				(setq ret true)
				(incf nEmpty))
              (t
				(when (> val max)
					(setq max val)
					(setq max_x x)
					(setq max_y y)
				)
				(when (not ret)
					(if (< x (1- XMAX))
						(let ((x1 (getCell (1+ x) y)))
                            (if (or (eql val x1) (zerop x1))
                                (setq ret true)
                            ))
					)
					(if (< y (1- YMAX))
						(let ((y1 (getCell x (1+ y))))
                            (if (or (eql val y1) (zerop y1))
                                (setq ret true)
                            ))
					)
				))
			)
          )
		)
	)
	(if (and (or (zerop max_x) (eql max_x (1- XMAX))) (or (zerop max_y) (eql max_y (1- YMAX))))
		(if D_BONUS_USE_MAX
			(setq nBonus max)
			(setq nBonus D_BONUS)
		)
	)
	(return (values ret nEmpty nBonus))
))

(defmacro calcGap(a b edgea edgeb) `(prog ;float64
	((ret 0))
	(incf *count_calcGap*)
	(cond ((> ,a ,b)
		(setq ret (- ,a ,b))
		(if (and (> *calc_gap_mode* 0) (not ,edgea) ,edgeb)
			(case *calc_gap_mode*
              (1 (incf ret))
              (2 (setq ret (* ret 2)))
              (3 (incf ret ,a))
              (4 (incf ret (/ ,a 10)))
              (5 (incf ret (+ ,a ,b)))
			)
		))
      ((< ,a ,b)
		(setq ret (- ,b ,a))
		(if (and (> *calc_gap_mode* 0) ,edgea (not ,edgeb))
			(case *calc_gap_mode*
              (1 (incf ret))
              (2 (setq ret (* ret 2)))
              (3 (incf ret ,b))
              (4 (incf ret (/ ,b 10)))
              (5 (incf ret (+ ,a ,b)))
			)
		))
      (t
		(setq ret GAP_EQUAL))
	)
	(return ret)
))

(defun getGap1(nGapBest nEmpty nBonus) (prog ;float64
	((ret 0.0)
     (ret_appear 0.0)
     (alpha (* nGapBest nBonus))
     (edgea false)
     (edgeb false)
     v)
	(dotimes (x XMAX)
		(dotimes (y YMAX)
			(setq v (getCell x y))
			(setq edgea (or (zerop x) (zerop y) (eql x (1- XMAX)) (eql y (1- YMAX))))
			(cond ((> v 0)
				(if (< x (1- XMAX))
					(let ((x1 (getCell (1+ x) y)))
                      (setq edgeb (or (zerop y) (eql (1+ x) (1- XMAX)) (eql y (1- YMAX))))
                      (cond ((> x1 0)
                             (incf ret (calcGap v x1 edgea edgeb)))
                            (t
                              (incf ret_appear (/ (* (calcGap v INIT2 edgea edgeb) (1- RNDMAX)) RNDMAX))
                              (incf ret_appear (/ (calcGap v INIT4 edgea edgeb) RNDMAX)))
                            )
                      )
				)
				(if (< y (1- YMAX))
					(let ((y1 (getCell x (1+ y))))
                        (setq edgeb (or (zerop x) (eql x (1- XMAX)) (eql (1+ y) (1- YMAX))))
                        (cond ((> y1 0)
                            (incf ret (calcGap v y1 edgea edgeb)))
                          (t
                            (incf ret_appear (/ (* (calcGap v INIT2 edgea edgeb) (1- RNDMAX)) RNDMAX))
                            (incf ret_appear (/ (calcGap v INIT4 edgea edgeb) RNDMAX)))
                        )
                    )
				))
              (t
				(if (< x (1- XMAX))
					(let ((x1 (getCell (1+ x) y)))
                        (setq edgeb (or (zerop y) (eql (1+ x) (1- XMAX)) (eql y (1- YMAX))))
                        (when (> x1 0)
                            (incf ret_appear (/ (* (calcGap x1 INIT2 edgea edgeb) (1- RNDMAX)) RNDMAX))
                            (incf ret_appear (/ (calcGap x1 INIT4 edgea edgeb) RNDMAX))
                        ))
				)
				(if (< y (1- YMAX))
					(let ((y1 (getCell x (1+ y))))
                        (setq edgeb (or (zerop x) (eql x (1- XMAX)) (eql (1+ y) (1- YMAX))))
                        (when (> y1 0)
                            (incf ret_appear (/ (* (calcGap y1 INIT2 edgea edgeb) (1- RNDMAX)) RNDMAX))
                            (incf ret_appear (/ (calcGap y1 INIT4 edgea edgeb) RNDMAX))
                        ))
				))
			)
			(if (> (+ ret (/ ret_appear nEmpty)) alpha)
				(return-from getGap1 GAP_MAX)
			)
		)
	)
	(incf ret (/ ret_appear nEmpty))
	(setq ret (/ ret nBonus))
	(return ret)
))

(defun getGap(nAutoMode nGapBest) (prog ;float64
    ((ret 0.0))
	(incf *count_getGap*)
	(multiple-value-bind (movable nEmpty nBonus) (isMovable)
      (cond ((not movable)
            (setq ret GAP_MAX))
          ((<= nAutoMode 1)
            (setq ret (getGap1 nGapBest nEmpty nBonus)))
          (t
            (let ((alpha (* nGapBest (float nEmpty))))
              ;累積がこれを超えれば、平均してもnGapBestを超えるので即枝刈りする
                (dotimes (x XMAX)
                    (dotimes (y YMAX)
                        (when (isEmpty x y)
                            (setCell x y INIT2)
                            (incf ret (* (moveBest (1- nAutoMode) false) (- RNDMAX 1) (/ 1 RNDMAX)))
                            (if (>= ret alpha)
                                (return-from getGap GAP_MAX)	;枝刈り
                            )
                            (setCell x y INIT4)
                            (incf ret (/ (moveBest (1- nAutoMode) false) RNDMAX))
                            (if (>= ret alpha)
                                (return-from getGap GAP_MAX)	;枝刈り
                            )
                            (clearCell x y)
                        )
                    )
                )
                (setq ret (/ ret nEmpty)) ;平均値を返す
            ))
      )
      (return ret)
    )
))

(defun moveBest(nAutoMode move) (prog ;float64
	(nGap
	 nGapBest
	 (nDirBest 0)
	 (nDir 0)
	 (board_bak (copy-board *board* (make-array (list XMAX YMAX) :element-type 'fixnum))))
	(incf *sp*)
	(setq nGapBest GAP_MAX)
    (copy-board board_bak *board*)
	(when (> (move_up) 0)
		(setq nDir 1)
		(setq nGap (getGap nAutoMode nGapBest))
		(when (< nGap nGapBest)
			(setq nGapBest nGap)
			(setq nDirBest 1)
		)
	)
    (copy-board board_bak *board*)
	(when (> (move_left) 0)
		(setq nDir 2)
		(setq nGap (getGap nAutoMode nGapBest))
		(when (< nGap nGapBest)
			(setq nGapBest nGap)
			(setq nDirBest 2)
		)
	)
    (copy-board board_bak *board*)
	(when (> (move_down) 0)
		(setq nDir 3)
		(setq nGap (getGap nAutoMode nGapBest))
		(when (< nGap nGapBest)
			(setq nGapBest nGap)
			(setq nDirBest 3)
		)
	)
    (copy-board board_bak *board*)
	(when (> (move_right) 0)
		(setq nDir 4)
		(setq nGap (getGap nAutoMode nGapBest))
		(when (< nGap nGapBest)
			(setq nGapBest nGap)
			(setq nDirBest 4)
		)
	)
    (copy-board board_bak *board*)
	(decf *sp*)
	(when move
		(when (zerop nDirBest)
			(format t "~%*** Give UP ***~%")
			(setq nDirBest nDir)
		)
		(case nDirBest
		 (1 (move_up))
		 (2 (move_left))
		 (3 (move_down))
		 (4 (move_right))
		)
	)
	(return nGapBest)
))

(defun moveAuto(autoMode) (prog ;float64
	((empty (countEmpty))
     (sc (getScore)))
	(cond ((>= empty (* XMAX YMAX *turbo_minus_percent* 1/100))
		(decf autoMode *turbo_minus_percent_level*))
	    ((< empty (* XMAX YMAX *turbo_plus_percent* 1/100))
		 (incf autoMode *turbo_plus_percent_level*))
	)
	(cond ((< sc *turbo_minus_score*)
		(decf autoMode *turbo_minus_score_level*))
	    ((>= sc *turbo_plus_score*)
		 (incf autoMode *turbo_plus_score_level*))
	)
	(return (moveBest autoMode true))
))

(defun isGameOver() (prog()
	(multiple-value-bind (ret _1 _2) (isMovable)
        (declare (ignore _1 _2))
        (if ret
            (return false)
            (return true)
        )
    )
))

(defun main(&key
    (*auto_mode* *auto_mode*)
	(*print_mode* *print_mode*)
	(*print_mode_turbo* *print_mode_turbo*)
	(*pause_mode* *pause_mode*)
	(*seed* *seed*)
	(*one_time* *one_time*)
	(*turbo_minus_percent* *turbo_minus_percent*)
	(*turbo_minus_percent_level* *turbo_minus_percent_level*)
	(*turbo_minus_score* *turbo_minus_score*)
	(*turbo_minus_score_level* *turbo_minus_score_level*)
	(*turbo_plus_percent* *turbo_plus_percent*)
	(*turbo_plus_percent_level* *turbo_plus_percent_level*)
	(*turbo_plus_score* *turbo_plus_score*)
	(*turbo_plus_score_level* *turbo_plus_score_level*)
	(*calc_gap_mode* *calc_gap_mode*)
    )
    "
	*auto_mode* 読みの深さ(>0)
	*print_mode* 途中経過の表示間隔(0：表示しない)
	*print_mode_turbo* 0:PRINT_MODEに従う 1:TURBO_MINUS_SCOREを超えたら強制表示 2:TURBO_PLUS_SCOREを超えたら強制表示
	*pause_mode* 終了時に一時中断(0/1)
	*seed* 乱数の種
	*one_time* N回で終了
	*turbo_minus_percent* 空き率がこれ以上であれば読みの深さを下げる
	*turbo_minus_percent_level* 下げる読みの深さ
	*turbo_minus_score* 点数がこれ以下であれば読みの深さを下げる
	*turbo_minus_score_level* 下げる読みの深さ
	*turbo_plus_percent* 空き率がこれ以下であれば読みの深さを上げる
	*turbo_plus_percent_level* 上げる読みの深さ
	*turbo_plus_score* 点数がこれ以上であれば読みの深さを上げる
	*turbo_plus_score_level* 上げる読みの深さ
	*calc_gap_mode* gap計算モード(0:normal 1:端の方が小さければ+1 2:*2 3:+大きい方の値 4:+大きい方の値/10 5:+両方の値)
    "
    (format t "auto_mode=~S~%" *auto_mode*)
	(format t "print_mode=~S~%" *print_mode*)
	(format t "print_mode_turbo=~S~%" *print_mode_turbo*)
	(format t "pause_mode=~S~%" *pause_mode*)
	(format t "seed=~S~%" *seed*)
	(format t "one_time=~S~%" *one_time*)
	(format t "turbo_minus_percent=~S~%" *turbo_minus_percent*)
	(format t "turbo_minus_percent_level=~S~%" *turbo_minus_percent_level*)
	(format t "turbo_minus_score=~S~%" *turbo_minus_score*)
	(format t "turbo_minus_score_level=~S~%" *turbo_minus_score_level*)
	(format t "turbo_plus_percent=~S~%" *turbo_plus_percent*)
	(format t "turbo_plus_percent_level=~S~%" *turbo_plus_percent_level*)
	(format t "turbo_plus_score=~S~%" *turbo_plus_score*)
	(format t "turbo_plus_score_level=~S~%" *turbo_plus_score_level*)
	(format t "calc_gap_mode=~S~%" *calc_gap_mode*)
    (if (> *seed* 0)
        (seed *seed*)
        (seed t)
    )
    (init_game)
    (setq *total_start_time* (now))
    (setq *sum_score* 0)
    (setq *max_score* 0)
    (setq *min_score* most-positive-fixnum)
    (setq *count* 1)
    (loop
        (let ((gap (moveAuto *auto_mode*)))
            (incf *gen*)
            (appear)
            (disp gap
                (and (> *print_mode* 0)
                     (or    (zerop (mod *gen* *print_mode*))
                            (and (eql *print_mode_turbo* 1) (> *score* *turbo_minus_score*))
                            (and (eql *print_mode_turbo* 2) (> *score* *turbo_plus_score*)))))
            (if (isGameOver)
                (let ((sc (getScore)))
                    (disp gap true)
                    (incf *sum_score* sc)
                    (if (> sc *max_score*)
                        (progn
                            (setf *max_score* sc)
                            (setf *max_seed* *seed*)
                        )
                    )
                    (if (< sc *min_score*)
                        (progn
                            (setf *min_score* sc)
                            (setf *min_seed* *seed*)
                        )
                    )
                    (format t "Game Over! (level=~S seed=~S) ~A #~S Ave.=~S Max=~S(seed=~S) Min=~S(seed=~S)~%"
                        *auto_mode* *seed* (getTime) *count* (float (/ *sum_score* *count*))
                        *max_score* *max_seed* *min_score* *min_seed*)
                    (format t "getGap=~S calcGap=~S ~3,1F,~3,1F ~S%,~S ~S,~S ~S%,~S ~S,~S ~S *calc_gap_mode*=~S~%"
                        *count_getGap* *count_calcGap*
                        D_BONUS GAP_EQUAL
                        *turbo_minus_percent* *turbo_minus_percent_level*
                        *turbo_minus_score* *turbo_minus_score_level*
                        *turbo_plus_percent* *turbo_plus_percent_level*
                        *turbo_plus_score* *turbo_plus_score_level*
                        *print_mode_turbo* *calc_gap_mode*)
                    (if (> *one_time* 0)
                        (if (zerop (decf *one_time*))
                            (return)
                        )
                    )
                    (if (> *pause_mode* 0)
                        (if (yes-or-no-p "終了しますか？")
                            (return)
                        )
                    )
                    (incf *seed*)
                    (seed *seed*)
                    (init_game)
                    (incf *count*)
                )
            )
        )
	)
	(setf *total_last_time* (now))
	(format t "Total time = ~,1F (sec)~%" (/ (- *total_last_time* *total_start_time*) MICRO_SECOND))
)
